
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go-fx-fluctuation-alert-lambda: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/syrilster/go-fx-fluctuation-alert-lambda/FxTrigger.go (0.0%)</option>
				
				<option value="file1">github.com/syrilster/go-fx-fluctuation-alert-lambda/exchange/client.go (87.8%)</option>
				
				<option value="file2">github.com/syrilster/go-fx-fluctuation-alert-lambda/fxtrigger/config.go (55.6%)</option>
				
				<option value="file3">github.com/syrilster/go-fx-fluctuation-alert-lambda/fxtrigger/trigger.go (92.3%)</option>
				
				<option value="file4">github.com/syrilster/go-fx-fluctuation-alert-lambda/http/client.go (100.0%)</option>
				
				<option value="file5">github.com/syrilster/go-fx-fluctuation-alert-lambda/pkg/store/dynamo.go (85.0%)</option>
				
				<option value="file6">github.com/syrilster/go-fx-fluctuation-alert-lambda/pkg/store/mocks/dynamoDb.go (68.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/syrilster/go-fx-fluctuation-alert-lambda/fxtrigger"
)

func main() <span class="cov0" title="0">{
        lambda.Start(fxtrigger.Handler)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package exchange

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"

        "github.com/rs/zerolog/log"
        chttp "github.com/syrilster/go-fx-fluctuation-alert-lambda/http"
)

type ClientInterface interface {
        GetExchangeRate(ctx context.Context, request Request) (float32, error)
}

func NewClient(endpoint string, h chttp.Client, appID string) *Client <span class="cov1" title="1">{
        return &amp;Client{
                URL:         endpoint,
                HttpCommand: h,
                AppID:       appID,
        }
}</span>

type Client struct {
        URL         string
        HttpCommand chttp.Client
        AppID       string
}

func (c *Client) GetExchangeRate(ctx context.Context, request Request) (float32, error) <span class="cov10" title="6">{
        ctxLogger := log.Ctx(ctx)

        defaultResp := float32(0)
        httpRequest, err := http.NewRequest(http.MethodGet, c.buildCurrencyExchangeEndpoint(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return defaultResp, err
        }</span>

        <span class="cov10" title="6">resp, err := c.HttpCommand.Do(httpRequest)
        if err != nil </span><span class="cov1" title="1">{
                ctxLogger.Error().Err(err).Msgf("there was an error calling the currency exchange API. %v", err)
                return defaultResp, err
        }</span>

        <span class="cov9" title="5">defer func() </span><span class="cov9" title="5">{
                if err = resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error when closing:", err)
                }</span>
        }()

        <span class="cov9" title="5">if resp.StatusCode != http.StatusOK </span><span class="cov4" title="2">{
                log.Printf("status returned from currency exchange service %s", resp.Status)
                return defaultResp, fmt.Errorf("currency exchange service returned status: %s", resp.Status)
        }</span>

        <span class="cov6" title="3">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error().Err(err).Msgf("error reading currency exchange service data resp body (%s)", err)
                return defaultResp, err
        }</span>

        <span class="cov6" title="3">r := &amp;Response{}
        if err := json.Unmarshal(body, r); err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error().Err(err).Msgf("there was an error un marshalling the currency exchange API resp. %v", err)
                return defaultResp, err
        }</span>

        <span class="cov6" title="3">response := unMarshallExchangeRate(r, request)
        return response, nil</span>
}

func unMarshallExchangeRate(resp *Response, req Request) float32 <span class="cov6" title="3">{
        var fromCurrency = req.FromCurrency
        var toCurrency = req.ToCurrency
        var conversionMultiple float32
        var exchangeRate float32
        if strings.EqualFold(fromCurrency, "USD") </span><span class="cov1" title="1">{
                exchangeRate = getRateForCurrency(resp.Rates, toCurrency)
                conversionMultiple = exchangeRate
        }</span> else<span class="cov4" title="2"> if strings.EqualFold(toCurrency, "USD") </span><span class="cov1" title="1">{
                exchangeRate = getRateForCurrency(resp.Rates, fromCurrency)
                conversionMultiple = float32(1) / exchangeRate
        }</span> else<span class="cov1" title="1"> {
                // FromCurrency to USD and then USD to toCurrency
                exchangeRate = getRateForCurrency(resp.Rates, toCurrency)
                usdToFromCurrency := getRateForCurrency(resp.Rates, fromCurrency)
                toCurrencyToUSD := float32(1) / exchangeRate
                foreignCurrencyFactor := float32(1) / usdToFromCurrency
                conversionMultiple = foreignCurrencyFactor / toCurrencyToUSD
        }</span>

        <span class="cov6" title="3">return conversionMultiple</span>
}

func getRateForCurrency(rates map[string]interface{}, currency string) float32 <span class="cov7" title="4">{
        var exchangeRate float64
        for key, rate := range rates </span><span class="cov10" title="6">{
                if strings.EqualFold(key, currency) </span><span class="cov7" title="4">{
                        exchangeRate = rate.(float64)
                        break</span>
                }
        }
        <span class="cov7" title="4">return float32(exchangeRate)</span>
}

func (c *Client) buildCurrencyExchangeEndpoint() (endpoint string) <span class="cov10" title="6">{
        return c.URL + "?app_id=" + c.AppID
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package fxtrigger

import (
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
        "io/ioutil"
        "path/filepath"
)

type Config struct {
        ToEmail          string  //from Env
        FromEmail        string  `yaml:"fromEmail"`
        AWSRegion        string  `yaml:"awsRegion"`
        ExchangeEndpoint string  `yaml:"exchangeEndpoint"`
        ThresholdPercent float64 `yaml:"thresholdPercent"`
        FXTableName      string  `yaml:"fxTableName"`
        LowerBound       float64 //From env
        UpperBound       float64 //From env
        AppID            string  //From env
}

func (c *Config) getConfig(path string) *Config <span class="cov10" title="3">{
        bytes, err := ioutil.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Invalid Config Path")
                return nil
        }</span>

        <span class="cov10" title="3">err = yaml.Unmarshal(bytes, c)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Unable to marshall successfully")
                return nil
        }</span>
        <span class="cov10" title="3">return c</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package fxtrigger

import (
        "context"
        "errors"
        "fmt"
        "hash/fnv"
        "math"
        "os"
        "strconv"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/sesv2"
        "github.com/aws/aws-sdk-go-v2/service/sesv2/types"
        "github.com/rs/zerolog/log"

        "github.com/syrilster/go-fx-fluctuation-alert-lambda/exchange"
        "github.com/syrilster/go-fx-fluctuation-alert-lambda/http"
        "github.com/syrilster/go-fx-fluctuation-alert-lambda/pkg/ses"
        dynamo "github.com/syrilster/go-fx-fluctuation-alert-lambda/pkg/store"
)

const (
        awsRegion     = "ap-south-1"
        configPathKey = "CONFIG_PATH"
        lowerBound    = "LOWER_BOUND"
        upperBound    = "UPPER_BOUND"
)

var emailText = "HIGH"

type CustomEvent struct {
        Name string `json:"name"`
}

type ExchangeResponse struct {
        From   string `json:"from"`
        To     string `json:"to"`
        FXRate string `json:"conversion_multiple"`
}

type DBService struct {
        store dynamo.CurrencySaver
}

var fromCurrency string
var toCurrency string
var dbAmount float32

// NewDBService is accepting interface here
func NewDBService(s dynamo.CurrencySaver) *DBService <span class="cov7" title="5">{
        return &amp;DBService{
                store: s,
        }
}</span>

// Handler func for lambda
func Handler(ctx context.Context, request CustomEvent) error <span class="cov5" title="3">{
        var err error
        contextLogger := log.Ctx(ctx)
        contextLogger.Info().Msgf("Inside the lambda handler at date: %s", getLocalTime())
        contextLogger.Info().Msgf("Event Trigger: %s", request.Name)

        cfgPath := os.Getenv(configPathKey)

        log.Print("Loading Config from path:", configPathKey)
        var c Config
        cfg := c.getConfig(cfgPath)

        log.Print("Config Loaded Successfully")
        cfg.ToEmail = os.Getenv("TO_EMAIL")
        cfg.AppID = os.Getenv("APP_ID")
        fromCurrency = os.Getenv("FROM_CURRENCY")
        toCurrency = os.Getenv("TO_CURRENCY")

        if cfg.LowerBound, err = strconv.ParseFloat(os.Getenv(lowerBound), 32); err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprint("error while loading env var LOWER_BOUND ", err))
        }</span>

        <span class="cov5" title="3">if cfg.UpperBound, err = strconv.ParseFloat(os.Getenv(upperBound), 32); err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprint("error while loading env var UPPER_BOUND ", err))
        }</span>

        <span class="cov5" title="3">_, err = config.LoadDefaultConfig(context.TODO(), config.WithRegion(awsRegion))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Msgf("failed to load AWS configuration: %v", err)
                return err
        }</span>

        <span class="cov5" title="3">currencyStore := dynamo.NewCurrencyStore(cfg.FXTableName, dynamodb.New(dynamodb.Options{Region: awsRegion}))

        sesOptions := sesv2.Options{
                Region: awsRegion,
        }
        sesClient, err := ses.New(sesOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Msgf("failed to create SES client: %v", err)
                return err
        }</span>

        <span class="cov5" title="3">exchangeClient := exchange.NewClient(cfg.ExchangeEndpoint, http.New(), cfg.AppID)
        req := exchange.Request{
                FromCurrency: fromCurrency,
                ToCurrency:   toCurrency,
        }

        return process(ctx, cfg, currencyStore, sesClient, exchangeClient, req)</span>
}

func process(ctx context.Context, cfg *Config, store *dynamo.CurrencyStore, ses *ses.Client, eClient exchange.ClientInterface, request exchange.Request) error <span class="cov10" title="10">{
        ctxLogger := log.Ctx(ctx)

        log.Print("Calling exchange rate API")
        fxAmount, err := eClient.GetExchangeRate(ctx, request)
        if err != nil </span><span class="cov6" title="4">{
                ctxLogger.Error().Err(err).Msg("Error when getting the exchange rate")
                return errors.New("error when getting the exchange rate")
        }</span>
        <span class="cov8" title="6">log.Printf("exchange rate API returned fx rate: %f", fxAmount)

        sendEmail, err := checkThresholdSatisfied(ctx, store, fxAmount, float32(cfg.LowerBound), float32(cfg.UpperBound), cfg.ThresholdPercent)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error when checking threshold satisfied: %v", err)
        }</span>

        <span class="cov7" title="5">if sendEmail </span><span class="cov6" title="4">{
                log.Print("Attempting to send email notification")
                err := sesSendEmail(ses, fxAmount, cfg.ToEmail)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("error when sending email: %v", err)
                }</span>
        } else<span class="cov1" title="1"> {
                log.Print("FX Alert threshold not met")
                log.Printf("Current FX rate %v", fxAmount)
        }</span>

        <span class="cov6" title="4">return nil</span>
}

func checkThresholdSatisfied(ctx context.Context, store *dynamo.CurrencyStore, fxAmount, lowerBound, upperBound float32, thresholdPercent float64) (sendEmail bool, err error) <span class="cov8" title="6">{
        ctxLogger := log.Ctx(ctx)
        if fxAmount &gt;= upperBound || fxAmount &lt;= lowerBound </span><span class="cov7" title="5">{
                log.Print("FX threshold satisfied")
                log.Printf("Current FX rate %v", fxAmount)
                if fxAmount &lt;= lowerBound </span><span class="cov1" title="1">{
                        emailText = "LOW"
                }</span>

                <span class="cov7" title="5">hashString := fmt.Sprint(hash())
                ctxLogger.Info().Msgf("computed hash is %v", hashString)
                dbService := NewDBService(store)
                dbItem, err := dbService.getItem(hashString)
                if err != nil </span><span class="cov5" title="3">{
                        ctxLogger.Error().Err(err).Msg("key not found in DynamoDB")
                        log.Print("Creating an item in Dynamo with computed hash")
                        err := dbService.createItem(hashString, fxAmount)
                        if err != nil </span><span class="cov1" title="1">{
                                return false, err
                        }</span>
                        <span class="cov3" title="2">sendEmail = true
                        dbAmount = fxAmount</span>
                }

                <span class="cov6" title="4">if dbItem != nil </span><span class="cov3" title="2">{
                        log.Printf("Found item in DB by hash value: %s", hashString)
                        dbAmount = dbItem.CurrencyValue
                }</span>

                <span class="cov6" title="4">if thresholdExceedsPercentVal(thresholdPercent, fxAmount, dbAmount) </span><span class="cov3" title="2">{
                        sendEmail = true
                }</span>
        }
        <span class="cov7" title="5">return sendEmail, nil</span>
}

func thresholdExceedsPercentVal(threshold float64, currentVal, existingVal float32) bool <span class="cov6" title="4">{
        if currentVal == existingVal </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov3" title="2">log.Printf("Inside threshold func to check if threshold is greater than set percentage: %f", threshold)
        diff := math.Abs(float64(currentVal) - float64(existingVal))
        delta := (diff / float64(existingVal)) * 100
        log.Printf("percent diff with prev value is: %f", delta)
        return delta &gt; threshold</span>
}

func (d *DBService) createItem(hash string, amount float32) error <span class="cov5" title="3">{
        expires := getExpiryTime()
        rec := dynamo.Item{
                HashString:    hash,
                CurrencyValue: amount,
                Expires:       expires,
        }

        err := d.store.CreateItem(rec)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Err(err).Msg("dynamo create item error")
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func (d *DBService) getItem(hash string) (*dynamo.Item, error) <span class="cov7" title="5">{
        resp, err := d.store.GetItem(hash)
        if err != nil </span><span class="cov5" title="3">{
                log.Error().Err(err).Msg("dynamo getItem error")
                return nil, fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov3" title="2">return resp, nil</span>
}

func sesSendEmail(sesClient *ses.Client, amount float32, toEmail string) error <span class="cov6" title="4">{
        // Construct the SendEmailInput
        emailParams := &amp;sesv2.SendEmailInput{
                Content: &amp;types.EmailContent{
                        Simple: &amp;types.Message{
                                Subject: &amp;types.Content{
                                        Data: aws.String(fromCurrency + " to " + toCurrency + " Alert"),
                                },
                                Body: &amp;types.Body{
                                        Text: &amp;types.Content{
                                                Data: aws.String(fromCurrency + " to " + toCurrency + " value is " + emailText + ". Current value is " + fmt.Sprintf("%f", amount)),
                                        },
                                },
                        },
                },
                Destination: &amp;types.Destination{
                        ToAddresses: []string{toEmail},
                },
                FromEmailAddress: aws.String(toEmail),
        }

        // Send the email
        _, err := sesClient.SendEmail(context.TODO(), emailParams)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov5" title="3">return nil</span>
}

func hash() uint32 <span class="cov7" title="5">{
        loc, err := time.LoadLocation("Asia/Kolkata")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load local time for India, %v", err))</span>
        }
        <span class="cov7" title="5">t := time.Now().In(loc)
        localTime := t.Format("Mon Jan 2")
        //Compute the hash based on date
        h := fnv.New32a()
        _, _ = h.Write([]byte(localTime))
        return h.Sum32()</span>
}

func getLocalTime() string <span class="cov5" title="3">{
        loc, err := time.LoadLocation("Australia/Melbourne")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load local time for Melbourne, %v", err))</span>
        }
        <span class="cov5" title="3">t := time.Now().In(loc)
        localTime := t.Format("Mon Jan 2 15:04:05")
        return localTime</span>
}

func getExpiryTime() int64 <span class="cov5" title="3">{
        fmt.Print("Calculating expiry time ")
        loc, err := time.LoadLocation("Asia/Kolkata")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load local time for India, %v", err))</span>
        }
        <span class="cov5" title="3">t := time.Now().In(loc)
        return t.Add(time.Duration(14) * time.Hour).Unix()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import "net/http"

type Client interface {
        Do(req *http.Request) (resp *http.Response, err error)
}

type HTTP struct {
        client *http.Client
}

func New() *HTTP <span class="cov10" title="3">{
        return &amp;HTTP{client: http.DefaultClient}
}</span>

func (c HTTP) Do(req *http.Request) (resp *http.Response, err error) <span class="cov10" title="3">{
        return c.client.Do(req)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package store

import (
        "context"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/rs/zerolog/log"
)

type CurrencyStore struct {
        table    string
        dynamoDb dynamoDb
}

//go:generate mockery --name dynamoDb --structname DynamoDB
type dynamoDb interface {
        GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
        PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
}

type CurrencySaver interface {
        CreateItem(item Item) error
        GetItem(hash string) (*Item, error)
}

func NewCurrencyStore(t string, db dynamoDb) *CurrencyStore <span class="cov10" title="5">{
        return &amp;CurrencyStore{
                table:    t,
                dynamoDb: db,
        }
}</span>

// CreateItem write new entry into the DB table
func (d *CurrencyStore) CreateItem(item Item) error <span class="cov4" title="2">{
        av, err := attributevalue.MarshalMap(item)
        if err != nil || av == nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("error in CreateItem to db")
                return err
        }</span>

        <span class="cov4" title="2">_, err = d.dynamoDb.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: aws.String(d.table), Item: av,
        })
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("Couldn't add item to table. Error: %v", err)
        }</span>
        <span class="cov4" title="2">return err</span>
}

// GetItem gets items from a DynamoDB table based on a provided hash
func (d *CurrencyStore) GetItem(hash string) (*Item, error) <span class="cov7" title="3">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(d.table),
                Key: map[string]types.AttributeValue{
                        "hash": &amp;types.AttributeValueMemberS{Value: hash},
                },
        }

        response, err := d.dynamoDb.GetItem(context.TODO(), input)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("getItem error: %w", err)
        }</span>

        // Check if the item exists
        <span class="cov4" title="2">if len(response.Item) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("requested item not found")
        }</span>

        // Unmarshal the item into the provided struct
        <span class="cov1" title="1">item := &amp;Item{}
        err = attributevalue.UnmarshalMap(response.Item, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal item: %w", err)
        }</span>

        <span class="cov1" title="1">return item, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by mockery v2.50.4. DO NOT EDIT.

package mocks

import (
        context "context"

        dynamodb "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        mock "github.com/stretchr/testify/mock"
)

// DynamoDB is an autogenerated mock type for the dynamoDb type
type DynamoDB struct {
        mock.Mock
}

// GetItem provides a mock function with given fields: ctx, params, optFns
func (_m *DynamoDB) GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) <span class="cov10" title="8">{
        _va := make([]interface{}, len(optFns))
        for _i := range optFns </span><span class="cov0" title="0">{
                _va[_i] = optFns[_i]
        }</span>
        <span class="cov10" title="8">var _ca []interface{}
        _ca = append(_ca, ctx, params)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItem")</span>
        }

        <span class="cov10" title="8">var r0 *dynamodb.GetItemOutput
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *dynamodb.GetItemInput, ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params, optFns...)
        }</span>
        <span class="cov10" title="8">if rf, ok := ret.Get(0).(func(context.Context, *dynamodb.GetItemInput, ...func(*dynamodb.Options)) *dynamodb.GetItemOutput); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params, optFns...)
        }</span> else<span class="cov10" title="8"> {
                if ret.Get(0) != nil </span><span class="cov10" title="8">{
                        r0 = ret.Get(0).(*dynamodb.GetItemOutput)
                }</span>
        }

        <span class="cov10" title="8">if rf, ok := ret.Get(1).(func(context.Context, *dynamodb.GetItemInput, ...func(*dynamodb.Options)) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params, optFns...)
        }</span> else<span class="cov10" title="8"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="8">return r0, r1</span>
}

// PutItem provides a mock function with given fields: ctx, params, optFns
func (_m *DynamoDB) PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) <span class="cov7" title="5">{
        _va := make([]interface{}, len(optFns))
        for _i := range optFns </span><span class="cov0" title="0">{
                _va[_i] = optFns[_i]
        }</span>
        <span class="cov7" title="5">var _ca []interface{}
        _ca = append(_ca, ctx, params)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PutItem")</span>
        }

        <span class="cov7" title="5">var r0 *dynamodb.PutItemOutput
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *dynamodb.PutItemInput, ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params, optFns...)
        }</span>
        <span class="cov7" title="5">if rf, ok := ret.Get(0).(func(context.Context, *dynamodb.PutItemInput, ...func(*dynamodb.Options)) *dynamodb.PutItemOutput); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params, optFns...)
        }</span> else<span class="cov7" title="5"> {
                if ret.Get(0) != nil </span><span class="cov7" title="5">{
                        r0 = ret.Get(0).(*dynamodb.PutItemOutput)
                }</span>
        }

        <span class="cov7" title="5">if rf, ok := ret.Get(1).(func(context.Context, *dynamodb.PutItemInput, ...func(*dynamodb.Options)) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params, optFns...)
        }</span> else<span class="cov7" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="5">return r0, r1</span>
}

// NewDynamoDB creates a new instance of DynamoDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDynamoDB(t interface {
        mock.TestingT
        Cleanup(func())
}) *DynamoDB <span class="cov0" title="0">{
        mock := &amp;DynamoDB{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
